#+PROPERTY: header-args :tangle vimrc
#+TITLE: My literate Vim configuration
# Note: export with org-babel-tangle (C-c C-v t)
# More info at: https://org-babel.readthedocs.io/en/latest/header-args/#tangle

#+html: <a href="https://www.vim.org/"><img alt="Vim" src="https://frama.link/vimrc-badge"></a>

#+html: <a href="https://orgmode.org/"><img alt="Org-mode" src="https://img.shields.io/badge/Powered%20by-Emacs%20Org--mode-blueviolet.svg?style=for-the-badge&color=019833"></a>

* Table of Contents                                                     :TOC_3:
- [[#introduction][Introduction]]
  - [[#how-the-magic-is-done][How the magic is done]]
- [[#preliminaries][Preliminaries]]
  - [[#nocompatible][Nocompatible]]
  - [[#syntax-on][Syntax on]]
  - [[#filetype-plugin-indent-on][filetype plugin indent on]]
  - [[#map-leader-key][Map leader key]]
  - [[#augroup-for-the-autocmds][Augroup for the autocmds]]
- [[#vim-plug-requires-git][Vim plug (requires git)]]
  - [[#autoinstall-vim-plug-unix-only][Autoinstall vim-plug (Unix-only)]]
  - [[#defining-the-directory-for-installed-plugins][Defining the directory for installed plugins]]
  - [[#declare-the-list-of-plugins][Declare the list of plugins]]
    - [[#vim-textobj-entire][vim-textobj-entire]]
    - [[#mru-viewing-recent-files][MRU (Viewing recent files)]]
    - [[#vim-searchindex-show-number-of-search-results][vim-searchindex (Show number of search results)]]
    - [[#vim-cool-disable-search-highlighting][vim-cool (disable search highlighting)]]
    - [[#skybison-autocomplete-system-for-the-cmdline][SkyBison (Autocomplete system for the cmdline)]]
    - [[#vim-highlightedyank-makes-yanked-region-apparent][vim-highlightedyank (Makes yanked region apparent)]]
    - [[#vim-signature-display-marks][vim-signature (display marks)]]
    - [[#vim-highlighturl-highlights-urls][vim-highlighturl (highlights urls)]]
    - [[#showmotion-highlight-landing-places-of-text-motions][ShowMotion (highlight landing places of text motions)]]
    - [[#vim-togglercursor-changes-the-shape-of-the-cursor-on-the-terminal][vim-togglercursor (changes the shape of the cursor on the terminal)]]
    - [[#vim-modusline-changes-status-line-color-according-to-mode][vim-modusline (changes status line color according to mode)]]
    - [[#vim-markdown-folding-fold-markdown-documents-by-section][vim-markdown-folding (Fold markdown documents by section)]]
    - [[#vim-rename-file-rename-buffer-and-file-from-within-vim][vim-rename-file (Rename buffer and file from within vim)]]
    - [[#vim-convert-color-to-convert-color-strings-to-different-formats][vim-convert-color-to (Convert color strings to different formats)]]
    - [[#lisper-vim-provides-lisp-repl-functionality-for-vim][lisper-vim (provides Lisp REPL functionality for vim)]]
    - [[#vim-gitbranch-shows-git-branch-on-statusline][vim-gitbranch (shows git branch on statusline)]]
    - [[#lightline-gitdiff-shows-number-of-changes-from-last-commit-on-statusline][lightline-gitdiff (shows number of changes from last commit on statusline)]]
    - [[#orgvim-syntax-highlighting-and-folding-for-org-mode-files][org.vim (syntax highlighting and folding for org-mode files)]]
    - [[#vim-freekeys-shows-free-keys-available-for-mappings][vim-freekeys (shows free keys available for mappings)]]
    - [[#syntaxattrvim-detection-of-syntax-group-under-cursor][SyntaxAttr.vim (detection of syntax group under cursor)]]
  - [[#initialize-the-plugin-system][Initialize the plugin system]]
- [[#plugin-settings][Plugin settings]]
  - [[#skybison-keymaps][SkyBison keymaps]]
  - [[#skybison-substring-matching][SkyBison substring matching]]
  - [[#shortcut-for-invoking-mru][Shortcut for invoking MRU]]
  - [[#duration-of-highlightedyank-in-milliseconds][Duration of highlightedyank (in milliseconds)]]
  - [[#color-of-marks-for-vim-signature][Color of marks for vim-signature]]
  - [[#vim-highlighturl-settings][Vim-highlighturl settings]]
    - [[#highlight-color][Highlight color]]
    - [[#enable-the-plugin-only-on-text-files][Enable the plugin only on text files]]
  - [[#bindings-of-showmotion-plugin][Bindings of ShowMotion plugin]]
  - [[#vim-modusline-color-settings][vim-modusline color settings]]
  - [[#vim-convert-color-to-keybinding][vim-convert-color-to keybinding]]
  - [[#lightline-gitdiff-indicators][lightline-gitdiff indicators]]
  - [[#syntaxattrvim-keybinding][SyntaxAttr.vim keybinding]]
- [[#colorscheme-settings][Colorscheme settings]]
- [[#settings-for-gvim][Settings for Gvim]]
- [[#various-settings][Various settings]]
  - [[#keybindings][Keybindings]]
  - [[#netrw][Netrw]]
  - [[#autocmd-for-help-buffers][Autocmd for help buffers]]
  - [[#difforig-command][DiffOrig command]]
- [[#search-settings][Search settings]]
- [[#custom-statusline][Custom statusline]]
- [[#nationality-and-keymap-settings][Nationality and keymap settings]]
  - [[#greek-letters-mapping][Greek letters mapping.]]

* Introduction
A while ago, I thought I'd try out Vim, to see what the fuss was about. Turns out I like its modal editing method a lot. What I miss from emacs though is having a literate configuration file, as I like making comments on my config options, and filling the vimrc file with comments doesn't look very clean. Then I remembered the existence of org-babel, and after reading [[https://orgmode.org/worg/org-contrib/babel/languages.html][that tangling is language-agnostic]], I thought I’d try it out.
** How the magic is done
I put in the beginning of this org file the string
#+BEGIN_EXAMPLE
#+PROPERTY: header-args :tangle vimrc
#+END_EXAMPLE
which tells the src blocks to get tangled (= exported) to a file called vimrc, so that vim will be able to see it. The tangling is triggered by the command ~org-babel-tangle~, which has the shortcut ~C-c C-v t~. During my testing however I discovered that the global property doesn't work if a specific language isn't specified in the code blocks (tangling though worked when I had ~:tangle~ on every single source block, but that wasn't very practical). And since vimscript isn't supported by babel (though it could be, if someone wrote a plugin for that - but that won't be me, as I don't know enough emacs lisp nor vimscript for that), I decided to use org (which is supported) as a placeholder.
* Preliminaries
** Nocompatible
One thing that vim users are told to put in their vimrc files is ~set nocompatible~ in order to kill pesky vi behavior. However, it turns out that this particular line is unnecessary, as the help file informs that the compatible option is turned off if a vimrc file is found. I keep it in my file though, albeit commented out, in order to remember this fact.
#+BEGIN_SRC org
" set nocompatible
#+END_SRC
** Syntax on
Here I enable the syntax because while this might happen automatically on Linux, this isn't the case on one of my Windows machines.
#+BEGIN_SRC org
syntax on
#+END_SRC
** filetype plugin indent on
This might be this way by default on Linux, but this isn't the case with one of my Windows machines.
#+BEGIN_SRC org
filetype plugin indent on
#+END_SRC
** Map leader key
I decided to map leader to space after all because the default \ key is on a different place in one of the laptops I use, and I don't use space in normal mode.
#+BEGIN_SRC org
let mapleader="\<Space>"
#+END_SRC
** Augroup for the autocmds
See [[https://gist.github.com/romainl/6e4c15dfc4885cb4bd64688a71aa7063][Dealing with autocommands · GitHub]] and [[https://www.reddit.com/r/vim/comments/4p4ogb/augroup_autocmd_need_some_clarification/d4i14it?utm_source=share&utm_medium=web2x][this r/vim post]]. To be honest, I wish the autocmds didn't have the tendency to be run again regardless of whether they were ran already, so that any sort of augroup wouldn't be necessary (as the rough equivalent on emacs, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][Hooks]], doesn't need anything of the sort), and I don't really source my vimrc (I tend to close and re-open Vim instead), but might as well put this here - it won't do any harm. Note to self: Not sure if I should add the autocmd used for auto-installing vim-plug to an augroup - it's the only one I left out of this augroup. Also the autocmd provided for vim-highlighturl was in its own augroup already, as this is how its author had written it).
#+BEGIN_SRC org
augroup myautocmds
    autocmd!
augroup END
#+END_SRC
* Vim plug (requires git)
  Initially, I started out without plugins. But I installed some after a while, to make my life with vim easier. Vim-plug however requires git, and I generally don't have that installed on my Windows machines, which is why I wrapped this whole section in a conditional that checks if the system has the git executable available (this way I'll account for any Windows machines with git or Unix machines without git I might encounter in the future). On my git-less Windows machines, I'll use Vim 8's [[https://shapeshed.com/vim-packages/][native package loading]], and manually place the plugins into the correct folder. It might not be the most convenient way, but at least it doesn't require git, _and_ I'll get to use my plugins.
** Autoinstall vim-plug (Unix-only)
From [[https://github.com/junegunn/vim-plug/wiki/tips#automatic-installation][tips · junegunn/vim-plug Wiki · GitHub]]. This part probably requires a Unix system, since it uses curl, hence the conditional that checks if the system is Unix wrapped around it. In case I'm on a Windows system with git, I'll probably download and place the file in the correct folder manually.
#+BEGIN_SRC org
if executable('git')

if has("unix")
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
endif
#+END_SRC
** Defining the directory for installed plugins
Features a conditional for using different directories on Unix and Windows with git systems (from [[https://vi.stackexchange.com/a/15227][https://vi.stackexchange.com/a/15227]]).
#+BEGIN_SRC org
if has('win32')
    let $MYPLUGDIRECTORY = "~/vimfiles/plugins"
else
    let $MYPLUGDIRECTORY = "~/.vim/plugins"
endif

call plug#begin($MYPLUGDIRECTORY)
#+END_SRC
** Declare the list of plugins
*** vim-textobj-entire
This is a custom textobject which allows me to easily select the entire buffer, most useful for when I want to paste something over it (because it turns out I can copy the entire buffer with ~:%y~). It provides the text object ae for the entire buffer, ie for the entire buffer except leading and trailing empty lines.
#+BEGIN_SRC org
" Declare the list of plugins.
" dependency of vim-textobj-entire
Plug 'kana/vim-textobj-user'
" provides the text object ae for the entire buffer, ie for the entire buffer except leading and trailing empty lines
Plug 'kana/vim-textobj-entire'
#+END_SRC
*** MRU (Viewing recent files)
I wanted to be able to view the files I had recently opened easily, and Ctrl-P didn't work as it doesn't recognise non-latin characters. I'm using thus MRU which is a good simple plugin for that purpose. Initially I was missing a feature to remove items from the recent files list without resorting to editing the file it uses to store the list by hand, but then found lilydjwg's fork, which implemented this functionality. It was missing though some of the changes the creator yegappan had made upstream, so I made my own fork which combines the two, and which is the one I use.
#+BEGIN_SRC org
" simple plugin to view list of recently opened files.
Plug 'lmintmate/MRU'
#+END_SRC
*** vim-searchindex (Show number of search results)
By default vim doesn't show the number of search results. [[https://github.com/google/vim-searchindex][This plugin]] fixes that.
#+BEGIN_SRC org
" shows number of search results
Plug 'google/vim-searchindex'
#+END_SRC
*** vim-cool (disable search highlighting)
Another annoying default behavior of Vim is that it keeps the highlighting of the search results even when I finished with the search. [[https://github.com/romainl/vim-cool][This plugin]] disables the search highlighting when any button is pressed.
#+BEGIN_SRC org
" disables search highlighting when you are done searching and re-enables it when you search again
Plug 'romainl/vim-cool'
#+END_SRC
*** SkyBison (Autocomplete system for the cmdline)
Another thing I missed from emacs was a completion framework. [[https://github.com/paradigm/SkyBison][SkyBison]] fixes this. I use it for completion of general commands, help topics, finding files, and buffers.
#+BEGIN_SRC org
" Autocomplete system for the cmdline
Plug 'paradigm/SkyBison'
#+END_SRC
*** vim-highlightedyank (Makes yanked region apparent)
[[https://github.com/machakann/vim-highlightedyank][This plugin]] briefly highlights the text that's being yanked. It has helped me quite a bit because I often miscalculate the area I am to yank.
#+BEGIN_SRC org
" Makes the yanked region apparent
Plug 'machakann/vim-highlightedyank'
#+END_SRC
*** vim-signature (display marks)
[[https://github.com/kshenoy/vim-signature][This plugin]] displays the marks created by the user on the signs column, which is good for remembering which marks were created.
#+BEGIN_SRC org
Plug 'kshenoy/vim-signature'
#+END_SRC
*** vim-highlighturl (highlights urls)
[[https://github.com/itchyny/vim-highlighturl][This plugin]] does roughly the equivalent of emacs's goto-address-mode, that is it highlights urls (it doesn't make them clickable though, unlike emacs).
#+BEGIN_SRC org
Plug 'itchyny/vim-highlighturl'
#+END_SRC
*** ShowMotion (highlight landing places of text motions)
This plugin highlights the possible landing places of various text motions, thus giving some help on using these motions. I'm using my own fork because I changed the highlight colors to suit my colorscheme.
#+BEGIN_SRC org
Plug 'lmintmate/ShowMotion'
#+END_SRC
*** vim-togglercursor (changes the shape of the cursor on the terminal)
[[https://github.com/jszakmeister/vim-togglecursor][This plugin]] changes the shape of the cursor on the terminal for insert and replace modes, to a vertical and a horizontal line respectively (as opposed to being a block in all of them). A similar plugin is [[https://github.com/wincent/terminus][terminus]], but I preferred to use this one instead as this one only configures the shape of the cursor and nothing else, while the other one also modifies some other stuff that I don't care about (so why use that if I was going to use only one feature of it?).
#+BEGIN_SRC org
Plug 'jszakmeister/vim-togglecursor'
#+END_SRC
*** vim-modusline (changes status line color according to mode)
[[https://github.com/sunaku/vim-modusline][This plugin]] changes the color of the statusline according to the mode, using the hl highlight colors, which means that the colors depend on the used colorscheme. Since I am using a custom statusline, this is a good solution for me to get the statusline to change color without having to use a statusline plugin (e.g. lightline).
#+BEGIN_SRC org
Plug 'sunaku/vim-modusline'
#+END_SRC
*** vim-markdown-folding (Fold markdown documents by section)
[[https://github.com/masukomi/vim-markdown-folding][This plugin]] folds markdown documents by section, using the existing folding system. I load it only for the markdown files.
#+BEGIN_SRC org
Plug 'masukomi/vim-markdown-folding', { 'for': 'markdown' }
#+END_SRC
*** vim-rename-file (Rename buffer and file from within vim)
[[https://github.com/pbrisbin/vim-rename-file][This plugin]] allows for renaming a file from within said file, without having to close it and go to the filemanager.
#+BEGIN_SRC org
Plug 'pbrisbin/vim-rename-file'
#+END_SRC
*** vim-convert-color-to (Convert color strings to different formats)
[[https://github.com/amadeus/vim-convert-color-to][This plugin]] converts color strings between many different formats e.g. hsl to hex.
#+BEGIN_SRC org
Plug 'amadeus/vim-convert-color-to'
#+END_SRC
*** lisper-vim (provides Lisp REPL functionality for vim)
[[https://github.com/mattn/lisper-vim][This made by mattn plugin]] provides functions that can evaluate lisp code from within vim, which can thus help me have a nifty little [[https://en.wikipedia.org/wiki/Polish_notation][prefix notation]] calculator for when I don't feel like opening emacs for this. Most useful for me are the functions ~:LisperEvalLine~, which evaluates the line on which the cursor is and shows the result on the commandline at the bottom of the screen, and ~:LisperRepl~, which creates a REPL environment on the bottom of the screen. Said REPL can be exited by typing ~(exit)~. I use [[https://github.com/dahu/lisper-vim][the fork made by dahu, since it's 1 commit ahead]].
#+BEGIN_SRC org
Plug 'dahu/lisper-vim'
#+END_SRC
*** vim-gitbranch (shows git branch on statusline)
[[https://github.com/itchyny/vim-gitbranch][This plugin]] shows the current git branch on the statusline, and thus provides a quick way for me to see if a file is under version control, so that I'll be more careful manipulating it.
#+BEGIN_SRC org
Plug 'itchyny/vim-gitbranch'
#+END_SRC
*** lightline-gitdiff (shows number of changes from last commit on statusline)
[[https://github.com/niklaas/lightline-gitdiff/][This plugin]], which, despite its name, doesn't require lightline to use, shows the number of changes from the last commit on the statusline. I use it in combination with vim-gitbranch because that one only shows if a file is under version control and not whether I changed anything.
#+BEGIN_SRC org
Plug 'niklaas/lightline-gitdiff'
#+END_SRC
*** org.vim (syntax highlighting and folding for org-mode files)
I was tired of seeing the org-mode files be detected as conf and highlighted incorrectly by vim, so I tried finding a plugin that would provide syntax highlighting. The most popular by far is [[https://github.com/jceb/vim-orgmode][vim-orgmode]], but that implements a lot of additional stuff I don't want, plus it complained that an optional plugin I didn't want was missing every time. I tried next [[https://github.com/filipelbc/orgmode.vim][orgmode.vim]], but that one defined the highlight colors in the plugin itself, and thus made a lot of color choices I didn't like, and I would have to change a lot of settings (if I was even able to) to achieve a better look. Finally I found [[https://github.com/axvr/org.vim][this plugin]], which is pretty much what I wanted from an org-mode plugin for vim (after all, if I want something more advanced, I'll do it from emacs), and it also draws its colors from the used colorscheme. Only slight drawback is that some things are colored differently than what I would ideally like (e.g. headline levels 1, 2 and 3 have the same color), but that doesn't change the fact that I'm glad to have found this plugin. 
#+BEGIN_SRC org
Plug 'axvr/org.vim'
#+END_SRC
*** vim-freekeys (shows free keys available for mappings)
I wanted a vim equivalent of the emacs package [[https://github.com/Fuco1/free-keys][free-keys]]. I found it [[https://github.com/lacygoill/vim-freekeys][here]]. Only problem it had was that it errored out when the <Leader> wasn't defined, which was another reason I ended up setting mapleader.
#+BEGIN_SRC org
Plug 'lacygoill/vim-freekeys'
#+END_SRC
*** SyntaxAttr.vim (detection of syntax group under cursor)
I've been thinking for a while that it would be nice to be able to see what syntax group a string under the cursor uses (something akin to emacs's ~decribe-face~).[[https://github.com/inkarkat/SyntaxAttr.vim][This plugin]] does this.
#+BEGIN_SRC org
Plug 'inkarkat/SyntaxAttr.vim'
#+END_SRC
** Initialize the plugin system
#+BEGIN_SRC org
" Initialize plugin system
call plug#end()
endif
#+END_SRC
* Plugin settings
Here are set the plugin-specific settings.
** SkyBison keymaps
The bindings for invoking SkyBison: general, for buffers, for help and for file finding.
#+BEGIN_SRC org
" SkyBison keymaps
" general
nnoremap <silent> <leader>s :<c-u>call SkyBison("")<cr>
"for buffers
nnoremap <silent> <leader>b :<c-u>call SkyBison("b ")<cr>
" for help
nnoremap <silent> <leader>h :<c-u>call SkyBison("h ")<cr>
" for file finding
nnoremap <silent> <leader>e :<c-u>call SkyBison("e ")<cr>
#+END_SRC
** SkyBison substring matching
This setting makes SkyBison match exact strings, no matter where in the word they are, thus bringing it closer to what I'm used to from ido and ivy.
#+BEGIN_SRC org
" SkyBison substring matching
let g:skybison_fuzz = 2
#+END_SRC
** Shortcut for invoking MRU
#+BEGIN_SRC org
" MRU shortcut
nnoremap <silent> <leader>r :MRU<cr>
#+END_SRC
** Duration of highlightedyank (in milliseconds)
#+BEGIN_SRC org
" duration of highlightedyank highlight in milliseconds
let g:highlightedyank_highlight_duration = 590
#+END_SRC
** Color of marks for vim-signature
Their default color is red, which doesn't look too good on my colorscheme. With the setting below, I set their color to green, so that they'll look better.
#+BEGIN_SRC org
let g:SignatureMarkTextHL = "Title"
#+END_SRC
** Vim-highlighturl settings
*** Highlight color
The default one is darker than I wish it to be.
#+BEGIN_SRC org
let g:highlighturl_guifg ='#00ffff'
#+END_SRC
*** Enable the plugin only on text files
The other filetypes where urls are usually encountered (e.g. markdown) manage the url highlighting by themselves, so no need to enable it there (code adapted from the example in the doc file). I'm enabling this conditionally so that it won't show an error if the plugin isn't present.
#+BEGIN_SRC org
if exists('g:loaded_highlighturl')
let g:highlighturl_enable = 0
	augroup highlighturl-filetype
	  autocmd!
	  autocmd FileType text call highlighturl#enable_local()
augroup END
endif
#+END_SRC
** Bindings of ShowMotion plugin
Make them conditional, so that they will work in the default manner if the plugin isn't present.
#+BEGIN_SRC org
autocmd myautocmds VimEnter * call s:showmotion_bindings()
function! s:showmotion_bindings() abort
if exists('g:loaded_showmotion')
"*** Only highlights motions corresponding to the one you typed
nmap w <Plug>(show-motion-w)
nmap W <Plug>(show-motion-W)
nmap b <Plug>(show-motion-b)
nmap B <Plug>(show-motion-B)
nmap e <Plug>(show-motion-e)
nmap E <Plug>(show-motion-E)
nmap ge <Plug>(show-motion-ge)
nmap gE <Plug>(show-motion-gE)
"Show motion for chars:
nmap f <Plug>(show-motion-f)
nmap t <Plug>(show-motion-t)
nmap F <Plug>(show-motion-F)
nmap T <Plug>(show-motion-T)
nmap ; <Plug>(show-motion-;)
nmap , <Plug>(show-motion-,)
endif
endfunction
#+END_SRC
** vim-modusline color settings
In regards to the default colors used by modusline, I didn't want to use all of the defaults as they were, as, for example, the defined by modusline color of the terminal mode overrode StatusLineTerm. I initially couldn't override this however, so [[https://github.com/sunaku/vim-modusline/issues/1][the author of the plugin gave me an autocommand to use]], and this worked.\\
At first I thought I could only use the colors defined by my colorscheme, and since it didn't define much stuff with a solid bg, my statusline didn't look as good as it could have. But then I found out about the existence of a number of custom highlight parameters reserved for the user, namely ~hl-User1..9~, via [[https://kadekillary.work/post/statusline-vim/][this blogpost]] , so I thought that I could use those to highlight my statusline any way I wanted. When I first tried to set the highlights just by themselves however, they were being cleared by the colorscheme, no matter if I set it before or after the vim-modusline setting. I looked the problem up, and [[https://vi.stackexchange.com/a/3356][found out]] that I have to put these highlights in an autocmd to be executed with the colorscheme if I want to prevent them being cleared.\\
Thus below I first set the User1..3 highlights with an autocmd and then override the modusline defaults for insert, visual and replace modes. The new colors for these ones are drawn from the lightline theme I created. I also had already replaced modusline's highlight of terminal mode with the one that is default in my colorscheme. I load this customization conditionally so that it won't show an error if the plugin is absent.
#+BEGIN_SRC org
autocmd myautocmds ColorScheme *
        \ hi User1 guifg=#000000 guibg=#7fff00 |
        \ hi User2 guifg=#000000 guibg=#ffd700 |
        \ hi User3 guifg=#000000 guibg=#ff6347

autocmd myautocmds VimEnter * call s:customize_modusline()
function! s:customize_modusline() abort
if exists('g:loaded_modusline')
  " do your customization here, inside this function
  let g:modusline_colors['i'] = '%#User1#'
  let g:modusline_colors['v'] = '%#User2#'
  let g:modusline_colors['V'] = '%#User2#'
  let g:modusline_colors["\<C-V>"] = '%#User2#'
  let g:modusline_colors['R'] = '%#User3#'
  let g:modusline_colors['Rv'] = '%#User3#'
  let g:modusline_colors['t'] = '%#StatusLineTerm#'
endif  
endfunction
#+END_SRC
** vim-convert-color-to keybinding
When I want to convert multiple lines from one color format to another (e.g hsl to hex) with this plugin, a macro is the most convenient method. However writing the command on the command mode or scrolling up its history can be error-prone, as one might accidentally unleash a different command instead if they mistype or scroll further in the history than they intended (when testing the plugin for example, I accidentally unleashed a macro that attempted to write a new file instead!). Thus here I create a keybinding that calls the function, bound to ~<Leader>c~. As the ~:ConvertColorTo~ command requires an argument, this keybinding will be for converting to hex, as this is by far my most common usecase.
#+BEGIN_SRC org
nnoremap <silent> <leader>c :<c-u>call ConvertColorTo("hex ")<cr>
#+END_SRC
** lightline-gitdiff indicators
The default indicators are ~A:~ for added, ~D:~ for removed, and ~M:~ for modified. I prefer something more minimalist however.
#+BEGIN_SRC org
let g:lightline#gitdiff#indicator_added = '+'
let g:lightline#gitdiff#indicator_deleted = '-'
let g:lightline#gitdiff#indicator_modified = '≠'
#+END_SRC
** SyntaxAttr.vim keybinding
#+BEGIN_SRC org
nnoremap <silent> <leader>a :<c-u>call SyntaxAttr#SyntaxAttr()<cr>
#+END_SRC
* Colorscheme settings
Set termguicolors: Makes terminal vim compatible with gui themes.(Check if the option exists first though, in case an error is throw if that's not the case).
#+BEGIN_SRC org
if has('termguicolors')
set termguicolors
endif
#+END_SRC
Change color of PreProc for the builtin slate theme: The builtin theme slate is the one I'll use when blue-mood isn't available, but I don't like the default color of PreProc, so I link it to Identifier instead.
#+BEGIN_SRC org
autocmd myautocmds ColorScheme slate
        \ hi! link PreProc Identifier
#+END_SRC
Where I enable [[https://github.com/lmintmate/blue-mood-vim][my home-made colorscheme, blue-mood]]. I check first if the gui is running or the ~termguicolors~ feature exists. If any one of those two things is true, then I set my colorscheme to blue-mood, using a ~try/catch~ block with the builtin colorscheme slate as fallback so that it won't error out in case blue-mood isn't present (which might happen since I install it manually). If none of these is true (e.g. if I happen to use terminal vim with a version below 7.4.1799 - where iirc the ~termguicolors~ option was first added) then the builtin colorscheme slate is used.
#+BEGIN_SRC org
if has('gui_running') || has('termguicolors')
try
    colorscheme blue-mood
catch
    colorscheme slate
endtry
else
colorscheme slate
endif
#+END_SRC
This disables the annoying red on things like underscores in markdown mode (from [[https://github.com/tpope/vim-markdown/issues/79][Make highlighting of markdownError optional · Issue #79 · tpope/vim-markdown]])
#+BEGIN_SRC org
autocmd myautocmds FileType markdown hi link markdownError NONE
#+END_SRC
* Settings for Gvim
Font for Gvim: My preferred font is DejaVu Sans Mono, but that might not be installed on some Windows systems, so I'm using Consolas as a fallback.
#+BEGIN_SRC org
if has("win32")
    set guifont=DejaVu_Sans_Mono:h14,Consolas:h14
else
    set guifont=DejaVu\ Sans\ Mono\ 14
endif
#+END_SRC
Linespace - increases space between lines - fixes underscore not showing up in Gvim.
#+BEGIN_SRC org
set linespace=2
#+END_SRC
Disable toolbar in Gvim
#+BEGIN_SRC org
set guioptions-=T       " disable toolbar in Gvim
#+END_SRC
Disable gui tabline in Gvim - with this it will show the same one it uses for terminal vim.
#+BEGIN_SRC org
set guioptions-=e " Don't use gui tabline
#+END_SRC
Disable gui dialogs in Gvim for simple choices
#+BEGIN_SRC org
set guioptions+=c       " disable gui dialogs in Gvim for simple choices
#+END_SRC
Set shortcuts for hiding menubar and scrollbar - adapted from [[http://vim.wikia.com/wiki/Hide_toolbar_or_menus_to_see_more_text][Hide toolbar or menus to see more text | Vim Tips Wiki]].
#+BEGIN_SRC org
" hide menubar
nnoremap <silent> <F9> :if &go=~#'m'<Bar>set go-=m<Bar>else<Bar>set go+=m<Bar>endif<CR>
" hide scrollbar
nnoremap <silent> <F10> :if &go=~#'r'<Bar>set go-=r<Bar>else<Bar>set go+=r<Bar>endif<CR>
#+END_SRC
* Various settings
Wildmenu: visual autocomplete for command menu
#+BEGIN_SRC org
set wildmenu            " visual autocomplete for command menu
#+END_SRC
Wildmode: This determines how wildmenu will act. The default behavior (~wildmode=full~) completed the full name of the first option immediately, which was annoying because, more often than not, I do not wish to use that option. The setting below completes until the longest common string while showing the wildmenu, and tabbing a second time completes the full name of the remaining options.
#+BEGIN_SRC org
set wildmode=longest:full,full
#+END_SRC
Display incomplete commands
#+BEGIN_SRC org
set showcmd             " display incomplete commands
#+END_SRC
Prevents the initial message from showing up
#+BEGIN_SRC org
set shortmess+=I        " prevents the initial message from showing up
#+END_SRC
linebreak - prevents wrap mode from cutting words in the middle
#+BEGIN_SRC org
set linebreak           " prevents wrap mode from cutting words in the middle
#+END_SRC
Set relative line numbers to ease navigation by lines - toggle with :set rnu!
#+BEGIN_SRC org
set relativenumber      " set relative line numbers
#+END_SRC
scrolloff - set number of context lines to show above/below the cursor
#+BEGIN_SRC org
set scrolloff=4         " set number of context lines to show above/below cursor
#+END_SRC
Ask for confirmation on operations such as quit without saving
#+BEGIN_SRC org
set confirm             " ask for confirmation on operations
#+END_SRC
Set vim to use the system clipboard
#+BEGIN_SRC org
set clipboard=unnamed,unnamedplus " set vim to use the system clipboard
#+END_SRC
Switch to another buffer without asking for confirmation to save any unchanged changes.
#+BEGIN_SRC org
set hidden " switch to another buffer without asking for confirmation to save any unsaved changes
#+END_SRC
Disable beeping
#+BEGIN_SRC org
set belloff=all " disable beeping
#+END_SRC
Display partial lines at the bottom of the screen
#+BEGIN_SRC org
set display=lastline " display partial lines at the bottom of the screen
#+END_SRC
Set encoding as utf-8, because this might be the default on Linux, but that isn't the case on Windows (there the encoding is some ~cp1253~ nonsense - looking at Wikipedia it seems this is another name for an encoding called [[https://en.wikipedia.org/wiki/Windows-1253][Windows-1253]], an obsolete encoding for Greek).
#+BEGIN_SRC org
set encoding=utf-8
#+END_SRC
Set backspace, because it might already be defined like that on Linux, but not on Windows.
#+BEGIN_SRC org
set backspace=indent,eol,start
#+END_SRC
Enable mouse in the terminal as well. The mouse is already enabled on the gui by default, but not on the terminal. This fixes that.
#+BEGIN_SRC org
set mouse=a
#+END_SRC
** Keybindings
Keymap to have enter add a new line without entering insert mode - good for spacing out text. I used to have it as ~nnoremap <CR>o<Esc>k~, but it was a bit jarring for some reason. I realised a while after that Enter in the conventional text editors does not in fact add a line below, as I thought, but rather a line /above/ from where the cursor is, so I corrected my keybinding accordingly.
#+BEGIN_SRC org
nnoremap <CR> O<Esc>j
#+END_SRC
Delete letters without putting them in the clipboard
#+BEGIN_SRC org
nnoremap x "_x
nnoremap X "_X
#+END_SRC
Visual mode remapping so that the stuff I replace by pasting isn't copied to the clipboard (from [[https://stackoverflow.com/a/10723838]])
#+BEGIN_SRC org
" don't copy to the clipboard the stuff I replace by pasting
vnoremap p "_dp
vnoremap P "_dP
#+END_SRC
I sometimes want to be able to move by visual lines, and rebinding j and k to gj and gk broke prefixing j and k with numbers, so I bound these commands to the arrows which aren't used with a prefix (if at all) anyways.
#+BEGIN_SRC org
nnoremap <Up> gk
nnoremap <Down> gj
#+END_SRC
Keymap to save with ctrl-s. I decided to add this because sometimes I want to use a one-handed shortcut, since I might be holding something else (e.g. a book) with my other hand. However, I read online that this same shortcut is used as a stop signal by terminals, thus this keymap will only be active in Gvim (where I do my editing 99% of the time anyways). ~:up[date]~ is a command that writes the buffer only if it has been modified, which thus leaves the modification time unchanged if that is not the case.
#+BEGIN_SRC org
if has('gui_running')
nnoremap <silent> <c-s> :update<CR>
endif
#+END_SRC
Unmap ~<Ctrl-X>~ in visual mode only on Windows: I found out that there is a function in vim to increment numbers with ~<Ctrl-A>~ and decrement numbers with ~<Ctrl-X>~ on normal and visual modes (see ~:h CTRL-A~, ~:h v_CTRL_A~, ~:h CTRL_X~, ~:h v_CTRL_X~, and also [[https://medium.com/usevim/visual-mode-increment-cce60c8743dc][here]] and [[https://www.networkworld.com/article/2968352/tricks-to-play-with-vim.html][here]]).There is also a function that can create incrementing and decrementing sequences (see ~:h v_g_CTRL_A~ and ~:h v_g_CTRL_X~) However on Windows, ~<Ctrl-X>~ on visual mode cuts the text instead. ~:h v_CTRL_X~ informs that using ~silent! vunmap <C-X>~ disables this behavior and restores the decrementing behavior in its place.
#+BEGIN_SRC org
if has("win32")
silent! vunmap <C-X>
endif
#+END_SRC
Not a keybinding. but related: Add single alphanumeric characters to the list of stuff that can be incremented or decremented with ~Ctrl-A~ and ~Ctrl-X~. This is useful for things like lists with a letter index e.g. a), b), etc.
#+BEGIN_SRC org
set nrformats+=alpha
#+END_SRC	
** Netrw
Add relative line numbers to netrw: The below setting will help me navigate netrw buffers more easily, by showing relative line numbers.
#+BEGIN_SRC org
let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro nobl'
#+END_SRC
A note in regards to netrw: My mileage with it varies. On my Linux machine it exhibits no bugs whatsoever, so I'm fine with using it whenever I need to navigate the filesystem there. On my Windows machine however it exhibits enough bugs to annoy me and make me look for an alternative file browser. In this case (that is whenever netrw acts all buggy), [[https://github.com/cocopon/vaffle.vim][Vaffle]] is the solution that works the best for me. In short, I occasionally use the Vaffle plugin but only on those cases where netrw exhibits enough bugs to make me not want to use it.
** Autocmd for help buffers
This autocmd (idea from [[https://github.com/junegunn/dotfiles/blob/5485496191a5413b9bf073ea0660ed97ccefc53d/vimrc#L1765][a snippet from junegunn's dotfiles]], found via [[https://github.com/arzg/vim-tabhelp][this plugin]]) has help buffers cover the whole viewpane and enables using just q to exit from them. The original autocmd used ~BufEnter~ instead of ~BufWinEnter~ but that caused instances of SkyBison called from help buffers to error out with ~E16~, saying ~Invalid range: 2wincmd w~. Looking at SkyBison's source code, I saw that [[https://github.com/paradigm/SkyBison/blob/1bc37a87a2517c57d9421e06a6dbf974b73d9238/plugin/skybison.vim#L176][SkyBison briefly revisited the open buffer using a wincmd]], and this apparently counted as a ~BufEnter~ event which caused 2 wincmd commands to be executed. I thus changed the event to ~BufWinEnter~ which still enables this autocmd but also doesn't error out SkyBison.
#+BEGIN_SRC org
function! s:helptab()
  if &buftype == 'help'
    silent! :only
    nnoremap <silent> <buffer> q :bdelete<cr>
  endif
endfunction
autocmd myautocmds BufWinEnter *.txt call s:helptab()
#+END_SRC
** DiffOrig command
Found from the ~defaults.vim~ file. This provides a command that uses vimdiff to find the differences between how a file was originally loaded and its current version after changes were made - useful to see what changes were made before saving a file.
#+BEGIN_SRC org
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif
#+END_SRC
* Search settings
Display search matches as characters are entered
#+BEGIN_SRC org
set incsearch " display search matches as characters are entered
#+END_SRC
Highlight matches
#+BEGIN_SRC org
set hlsearch " highlight matches
#+END_SRC
ignorecase - Case insensitive search e.g. if I want to find Foo as well when searching for /foo
#+BEGIN_SRC org
set ignorecase          " case-insensitive search
#+END_SRC
smartcase - override the previous setting when the search pattern uses capitals e.g. /Foo finds only Foo.
#+BEGIN_SRC org
set smartcase " override the previous when search pattern uses capitals e.g. /Foo finds only Foo
#+END_SRC
* Custom statusline
I found that vim has a statusline, and wanted to have it be similar to emacs's modeline. I was tempted to use [[https://github.com/itchyny/lightline.vim][lightline]], but then noticed that, because it needs separate theming, would look out of place with my home-made theme (I hadn't yet made a lightline theme at the time, and even now that I have I don't feel like rewriting my entire statusline in order to make it slightly fancier). So I made a custom statusline instead (here is a good place to get started with the subject: [[https://shapeshed.com/vim-statuslines/]]). This statusline shows on the left side the file encoding, the file format, the file name, whether the file is modified, whether this is a help buffer, or a read-only buffer.\\
On the right side it shows the keymap, the filetype, the current line, and the percentage into file, and the current time. Note that the current time is updated only on the active buffer.
In addition, also on the left side of the statusline, I added the function provided by [[https://github.com/itchyny/vim-gitbranch][vim-gitbranch]] ~gitbranch#name~, in order to be able to see whether the file is in version control or not. However, I don't want this to error out while on Windows, where I don't have git installed, so I tell it to load only if the parameter ~g:loaded_gitbranch~, which is defined in vim-gitbranch, is present, as I'm not going to install a plugin about git on a gitless environment (code for said conditional loading adapted from [[https://stackoverflow.com/a/5986830][here]]). I also added the function provided by [[https://github.com/niklaas/lightline-gitdiff/][lightline-gitdiff]] ~lightline#gitdiff#get~, in order to be able to see what changes have been made to a version-controlled file since the last commit. Similarly to vim-gitbranch, I also have it load conditionally, this time depending on whether the variable ~g:lightline#gitdiff#cache~ is present.
#+BEGIN_SRC org
set laststatus=2 " always show status line
" beginning of statusline
set statusline=
set statusline+=\ %{&fileencoding?&fileencoding:&encoding} " encoding
set statusline+=\(%{&fileformat}\) " file format
set statusline+=\ %t " name of file in the buffer
set statusline+=%m " modified flag
set statusline+=%h " help buffer flag
set statusline+=%r " read-only flag
set statusline+=\ %{exists('g:loaded_gitbranch')?gitbranch#name():''}
set statusline+=\ %{exists('g:lightline#gitdiff#cache')?lightline#gitdiff#get():''}
set statusline+=%=
set statusline+=\ %k " keymap
set statusline+=\ %y " filetype
set statusline+=\ L%l " current line
set statusline+=\ %p%% " percentage into file
set statusline+=\ %{strftime(\"%H:%M\")}
set statusline+=\ 
" end of statusline
#+END_SRC
* Nationality and keymap settings
Enable greek input - switch inputs with ctrl+6
#+BEGIN_SRC org
set keymap=greek_utf-8  " enables greek input - switch inputs with ctrl+6
#+END_SRC
iminsert - I don't want greek as default though in insert mode, so this setting makes sure that's the case.
#+BEGIN_SRC org
set iminsert=0 " I dont want greek as default though in insert mode
#+END_SRC
imsearch - with this, when searching it inherits the keymap currently used in insert mode.
#+BEGIN_SRC org
set imsearch=-1 " with this when searching it inherits the keymap currently used in insert mode
#+END_SRC
** Greek letters mapping.
Map Greek letters to the respective on the keyboard Latin ones - for Normal, Visual, Select and Operator pending modes - in case I've forgotten to switch my system keyboard language from Greek (idea from [[https://www.void.gr/kargig/dot/vimrc]]). Another unforeseen advantage of these mappings for me is that I can now use the commands that jump to letters (f,F,t,T) in order to jump to Greek letters without having to change my system keyboard layout midway through.
#+BEGIN_SRC org
map α a
map Α A
map β b
map Β B
map γ g
map Γ G
map δ d
map Δ D
map ε e
map Ε E
map ζ z
map Ζ Z
map η h
map Η H
map θ u
map Θ U
map ι i
map Ι I
map κ k
map λ l
map Λ L
map μ m
map Μ M
map ν n
map Ν N
map ξ j
map Ξ J
map ο o
map Ο O
map π p
map Π P
map ρ r
map Ρ R
map σ s
map ς w
map τ t
map Τ T
map υ y
map φ f
map Φ F
map χ x
map ψ c
map ω v
map Ω V
map γγ gg
map αε ae
#+END_SRC
Tip for Greek spell-checking: write in the file you want to spellcheck ~:setlocal spell spelllang=el~, and it will download all necessary files and do the spellchecking by itself (tip from [[https://forum.ubuntu-gr.org/viewtopic.php?f=23&t=18008][Ubuntu-gr Forum - vim και ελληνικός ορθογράφος]])

#  LocalWords:  recognise colorscheme
