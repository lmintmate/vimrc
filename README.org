#+PROPERTY: header-args :tangle vimrc
#+TITLE: My literate Vim configuration
# Note: export with org-babel-tangle (C-c C-v t)
# More info at: https://org-babel.readthedocs.io/en/latest/header-args/#tangle
* Introduction
A while ago, I thought I'd try out Vim, to see what the fuss was about. Turns out I like its modal editing method a lot. What I miss from emacs though is having a literate configuration file, as I like making comments on my config options, and filling the vimrc file with comments doesn't look very clean. Then I remembered the existence of org-babel, and after reading [[https://orgmode.org/worg/org-contrib/babel/languages.html][that tangling is language-agnostic]], I thought I’d try it out.
** How the magic is done
I put in the beginning of this org file the string
#+BEGIN_EXAMPLE
#+PROPERTY: header-args :tangle vimrc
#+END_EXAMPLE
which tells the src blocks to get tangled (= exported) to a file called vimrc, so that vim will be able to see it. The tangling is triggered by the command ~org-babel-tangle~, which has the shortcut ~C-c C-v t~. During my testing however I discovered that the global property doesn't work if a specific language isn't specified in the code blocks (tangling though worked when I had ~:tangle~ on every single source block, but that wasn't very practical). And since vimscript isn't supported by babel (though it could be, if someone wrote a plugin for that - but that won't be me, as I don't know enough emacs lisp nor vimscript for that), I decided to use org (which is supported) as a placeholder.
** A note on the repository
In this here repository, I also include the old vimrc, just in case.
* Preliminaries
** Nocompatible
One thing that vim users are told to put in their vimrc files is ~set nocompatible~ in order to kill pesky vi behavior. However, it turns out that this particular line is unecessary, as the help file informs that the compatible option is turned off if a vimrc file is found. I keep it in my file though, albeit commented out, in order to remember this fact.
#+BEGIN_SRC org
" set nocompatible
#+END_SRC
** Syntax on
Here I enable the syntax because while this might happen automatically on Linux, this isn't the case on one of my Windows machines.
#+BEGIN_SRC org
syntax on
#+END_SRC
** filetype plugin indent on
This might be this way by default on Linux, but this isn't the case with one of my Windows machines.
#+BEGIN_SRC org
filetype plugin indent on
#+END_SRC
* Vim plug (requires git)
  Initially, I started out without plugins. But I installed some after a while, to make my life with vim easier. Vim-plug however requires git, and I generally don't have that installed on my Windows machines, which is why I wrapped this whole section in a conditional that checks if the system has the git executable available (this way I'll account for any Windows machines with git or Unix machines without git I might encounter in the future). On my git-less Windows machines, I'll use Vim 8's [[https://shapeshed.com/vim-packages/][native package loading]], and manually place the plugins into the correct folder. It might not be the most convenient way, but at least it doesn't require git, _and_ I'll get to use my plugins.
** Autoinstall vim-plug (Unix-only)
From [[https://github.com/junegunn/vim-plug/wiki/tips#automatic-installation][tips · junegunn/vim-plug Wiki · GitHub]]. This part probably requires a Unix system, since it uses curl, hence the conditional that checks if the system is Unix wrapped around it.
#+BEGIN_SRC org
if executable('git')

if has("unix")
if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
endif
endif
#+END_SRC
** Defining the directory for installed plugins
#+BEGIN_SRC org
" Plugins will be downloaded under the specified directory.
    call plug#begin('~/.vim/plugins')
#+END_SRC
** Declare the list of plugins
*** vim-textobj-entire
This is a custom textobject which allows me to easily select the entire buffer, most useful for when I want to paste something over it (because it turns out I can copy the entire buffer with ~:%y~). It provides the text object ae for the entire buffer, ie for the entire buffer except leading and trailing empty lines.
#+BEGIN_SRC org
" Declare the list of plugins.
" dependency of vim-textobj-entire
Plug 'kana/vim-textobj-user'
" provides the text object ae for the entire buffer, ie for the entire buffer except leading and trailing empty lines
Plug 'kana/vim-textobj-entire'
#+END_SRC
*** MRU (Viewing recent files)
I wanted to be able to view the files I had recently opened easily, and Ctrl-P didn't work as it doesn't recognise non-latin characters. I'm using thus MRU which is a good simple plugin for that purpose. Initially I was missing a feature to remove items from the recent files list without resorting to editing the file it uses to store the list by hand, but then found lilydjwg's fork, which implemented this functionality. It was missing though some of the changes the creator yegappan had made upstream, so I made my own fork which combines the two, and which is the one I use.
#+BEGIN_SRC org
" simple plugin to view list of recently opened files.
Plug 'lmintmate/MRU'
#+END_SRC
*** vim-searchindex (Show number of search results)
By default vim doesn't show the number of search results. This plugin fixes that.
#+BEGIN_SRC org
" shows number of search results
Plug 'google/vim-searchindex'
#+END_SRC
*** vim-cool (disable search highlighting)
Another annoying default behavior of Vim is that it keeps the highlighting of the search results even when I finished with the search. This plugin disables the search highlighting when any button is pressed.
#+BEGIN_SRC org
" disables search highlighting when you are done searching and re-enables it when you search again
Plug 'romainl/vim-cool'
#+END_SRC
*** SkyBison (Autocomplete system for the cmdline)
Another thing I missed from emacs was a completion framework. SkyBison fixes this. I use it for completion of general commands, help topics, finding files, and buffers.
#+BEGIN_SRC org
" Autocomplete system for the cmdline
Plug 'paradigm/SkyBison'
#+END_SRC
*** vim-highlightedyank (Makes yanked region apparent)
This briefly highlights the text that's being yanked. It has helped me quite a bit because I often miscalculate the area I am to yank.
#+BEGIN_SRC org
" Makes the yanked region apparent
Plug 'machakann/vim-highlightedyank'
#+END_SRC
*** vim-signature (display marks)
This plugin displays the marks created by the user on the signs column, which is good for remembering which marks were created.
#+BEGIN_SRC org
Plug 'kshenoy/vim-signature'
#+END_SRC
*** vim-highlighturl (highlights urls)
This plugin does roughly the equivalent of emacs's goto-address-mode, that is it highlights urls (it doesn't make them clickable though, unlike emacs).
#+BEGIN_SRC org
Plug 'itchyny/vim-highlighturl'
#+END_SRC
*** ShowMotion (highlight landing places of text motions)
This plugin highlights the possible landing places of various text motions, thus giving some help on using these motions. I'm using my own fork because I changed the highlight colors to suit my colorscheme.
#+BEGIN_SRC org
Plug 'lmintmate/ShowMotion'
#+END_SRC
*** vim-togglercursor (changes the shape of the cursor on the terminal)
[[https://github.com/jszakmeister/vim-togglecursor][This plugin]] changes the shape of the cursor on the terminal for insert and replace modes, to a vertical and a horizontal line respectively (as opposed to being a block in all of them). A similar plugin is [[https://github.com/wincent/terminus][terminus]], but I preferred to use this one instead as this one only configures the shape of the cursor and nothing else, while the other one also modifies some other stuff that I don't care about (so why use that if I was going to use only one feature of it?).
#+BEGIN_SRC org
Plug 'jszakmeister/vim-togglecursor'
#+END_SRC
*** vim-modusline (changes status line color according to mode)
[[https://github.com/sunaku/vim-modusline][This plugin]] changes the color of the statusline according to the mode, using the hl highlight colors, which means that the colors depend on the used colorscheme. Since I am using a custom statusline, this is a good solution for me to get the statusline to change color without having to use a statusline plugin (e.g. lightline).
#+BEGIN_SRC org
Plug 'sunaku/vim-modusline'
#+END_SRC
*** vim-markdown-folding (Fold markdown documents by section)
[[https://github.com/masukomi/vim-markdown-folding][This plugin]] folds markdown documents by section, using the existing folding system. I load it only for the markdown files.
#+BEGIN_SRC org
Plug 'masukomi/vim-markdown-folding', { 'for': 'markdown' }
#+END_SRC
*** vim-rename-file (Rename buffer and file from within vim)
[[https://github.com/pbrisbin/vim-rename-file][This plugin]] allows for renaming a file from within said file, without having to close it and go to the filemanager.
#+BEGIN_SRC org
Plug 'pbrisbin/vim-rename-file'
#+END_SRC
** Initialize the plugin system
#+BEGIN_SRC org
" Initialize plugin system
call plug#end()
endif
#+END_SRC
* Plugin settings
Here are set the plugin-specific settings.
** SkyBison keymaps
The bindings for invoking SkyBison: general, for buffers, for help and for file finding.
#+BEGIN_SRC org
" SkyBison keymaps
" general
nnoremap <silent> <leader>s :<c-u>call SkyBison("")<cr>
"for buffers
nnoremap <silent> <leader>b :<c-u>call SkyBison("b ")<cr>
" for help
nnoremap <silent> <leader>h :<c-u>call SkyBison("h ")<cr>
" for file finding
nnoremap <silent> <leader>e :<c-u>call SkyBison("e ")<cr>
#+END_SRC
** SkyBison substring matching
This setting makes SkyBison match exact strings, no matter where in the word they are, thus bringing it closer to what I'm used to from ido and ivy.
#+BEGIN_SRC org
" SkyBison substring matching
let g:skybison_fuzz = 2
#+END_SRC
** Shortcut for invoking MRU
#+BEGIN_SRC org
" MRU shortcut
nnoremap <silent> <leader>r :MRU<cr>
#+END_SRC
** Make highlightedyank work on vim older than 8.0.1394
The version of vim on Windows is currently below 8.0.1394 (it is 8.0.586), so I'll need to use the trick provided on the repo to get it to work there.
#+BEGIN_SRC org
if !exists('##TextYankPost')
  map y <Plug>(highlightedyank)
endif
#+END_SRC
** Duration of highlightedyank (in milliseconds)
#+BEGIN_SRC org
" duration of highlightedyank highlight in milliseconds
let g:highlightedyank_highlight_duration = 590
#+END_SRC
** Color of marks for vim-signature
Their default color is red, which doesn't look too good on my colorscheme. With the setting below, I set their color to green, so that they'll look better.
#+BEGIN_SRC org
let g:SignatureMarkTextHL = "Title"
#+END_SRC
** Vim-highlighturl settings
*** Highlight color
The default one is darker than I wish it to be.
#+BEGIN_SRC org
let g:highlighturl_guifg ='#00ffff'
#+END_SRC
*** Enable the plugin only on text files
The other filetypes where urls are usually encountered (e.g. markdown) manage the url highlighting by themselves, so no need to enable it there (code adapted from the example in the doc file).
#+BEGIN_SRC org
let g:highlighturl_enable = 0
	augroup highlighturl-filetype
	  autocmd!
	  autocmd FileType text call highlighturl#enable_local()
augroup END
#+END_SRC
** Bindings of ShowMotion plugin
#+BEGIN_SRC org
"*** Only highlights motions corresponding to the one you typed
nmap w <Plug>(show-motion-w)
nmap W <Plug>(show-motion-W)
nmap b <Plug>(show-motion-b)
nmap B <Plug>(show-motion-B)
nmap e <Plug>(show-motion-e)
nmap E <Plug>(show-motion-E)
nmap ge <Plug>(show-motion-ge)
nmap gE <Plug>(show-motion-gE)

"Show motion for chars:  
nmap f <Plug>(show-motion-f)
nmap t <Plug>(show-motion-t)
nmap F <Plug>(show-motion-F)
nmap T <Plug>(show-motion-T)
nmap ; <Plug>(show-motion-;)
nmap , <Plug>(show-motion-,)
#+END_SRC
** vim-modusline color settings
In regards to the default colors used by modusline, I didn't want to use all of the defaults as they were, as, for example, the defined by modusline color of the terminal mode overrode StatusLineTerm. I initially couldn't override this however, so [[https://github.com/sunaku/vim-modusline/issues/1][the author of the plugin gave me an autocommand to use]], and this worked. In this autocommand I also changed the default highlight of the Replace mode.
#+BEGIN_SRC org
autocmd VimEnter * call s:customize_modusline()
function! s:customize_modusline() abort
  " do your customization here, inside this function
  let g:modusline_colors['t'] = '%#StatusLineTerm#'
  let g:modusline_colors['R'] = '%#ErrorMsg#'
endfunction
#+END_SRC
* Colorscheme settings
Set termguicolors: Makes terminal vim compatible with gui themes.(Check if the option exists first though, in case an error is throw if that's not the case).
#+BEGIN_SRC org
if has('termguicolors')
set termguicolors
endif
#+END_SRC
Where I enable [[https://github.com/lmintmate/blue-mood-vim][my home-made colorscheme,blue-mood]]. I check first if the gui is running or the termguicolors feature exists. If any one of those two things is true, then I set my colorscheme to blue-mood. If none of these is true (e.g. if I happen to use terminal vim with a version below 7.4.1799 - where iirc the ~'termguicolors'~ option was first added) then the builtin colorscheme torte is used.
#+BEGIN_SRC org
if has('gui_running') || has('termguicolors')
colorscheme blue-mood
else
colorscheme torte
endif
#+END_SRC
This disables the annoying red on things like underscores in markdown mode (from [[https://github.com/tpope/vim-markdown/issues/79][Make highlighting of markdownError optional · Issue #79 · tpope/vim-markdown]])
#+BEGIN_SRC org
autocmd FileType markdown hi link markdownError NONE
#+END_SRC
* Settings for Gvim
Font for Gvim - DejaVu Sans Mono on Unix, Consolas on Windows (because DejaVu might not be installed there).
#+BEGIN_SRC org
if has("win32")
    set guifont=Consolas:h14
else
    set guifont=DejaVu\ Sans\ Mono\ 14
endif
#+END_SRC
Linespace - increases space between lines - fixes underscore not showing up in Gvim.
#+BEGIN_SRC org
set linespace=2
#+END_SRC
Disable toolbar in Gvim
#+BEGIN_SRC org
set guioptions-=T       " disable toolbar in Gvim
#+END_SRC
Disable gui tabline in Gvim - with this it will show the same one it uses for terminal vim.
#+BEGIN_SRC org
set guioptions-=e " Don't use gui tabline
#+END_SRC
Disable gui dialogs in Gvim for simple choices
#+BEGIN_SRC org
set guioptions+=c       " disable gui dialogs in Gvim for simple choices
#+END_SRC
Set shortcuts for hiding menubar and scrollbar - adapted from [[http://vim.wikia.com/wiki/Hide_toolbar_or_menus_to_see_more_text][Hide toolbar or menus to see more text | Vim Tips Wiki]].
#+BEGIN_SRC org
" hide menubar
nnoremap <silent> <F9> :if &go=~#'m'<Bar>set go-=m<Bar>else<Bar>set go+=m<Bar>endif<CR>
" hide scrollbar
nnoremap <silent> <F10> :if &go=~#'r'<Bar>set go-=r<Bar>else<Bar>set go+=r<Bar>endif<CR>
#+END_SRC
* Various settings
Wildmenu: visual autocomplete for command menu
#+BEGIN_SRC org
set wildmenu            " visual autocomplete for command menu
#+END_SRC
Wildmode: This determines how wildmenu will act. The default behavior (~wildmode=full~) completed the full name of the first option immediately, which was annoying because, more often than not, I do not wish to use that option. The setting below completes until the longest common string while showing the wildmenu, and tabbing a second time completes the full name of the remaining options.
#+BEGIN_SRC org
set wildmode=longest:full,full
#+END_SRC
Display incomplete commands
#+BEGIN_SRC org
set showcmd             " display incomplete commands
#+END_SRC
Prevents the initial message from showing up
#+BEGIN_SRC org
set shortmess+=I        " prevents the initial message from showing up
#+END_SRC
linebreak - prevents wrap mode from cutting words in the middle
#+BEGIN_SRC org
set linebreak           " prevents wrap mode from cutting words in the middle
#+END_SRC
Set relative line numbers to ease navigation by lines - toggle with :set rnu!
#+BEGIN_SRC org
set relativenumber      " set relative line numbers
#+END_SRC
scrolloff - set number of context lines to show above/below the cursor
#+BEGIN_SRC org
set scrolloff=4         " set number of context lines to show above/below cursor
#+END_SRC
Ask for confirmation on operations such as quit without saving
#+BEGIN_SRC org
set confirm             " ask for confirmation on operations
#+END_SRC
Set vim to use the system clipboard
#+BEGIN_SRC org
set clipboard=unnamed,unnamedplus " set vim to use the system clipboard
#+END_SRC
Switch to another buffer without asking for confirmation to save any unchanged changes.
#+BEGIN_SRC org
set hidden " switch to another buffer without asking for confirmation to save any unsaved changes
#+END_SRC
Disable beeping
#+BEGIN_SRC org
set belloff=all " disable beeping
#+END_SRC
Display partial lines at the bottom of the screen
#+BEGIN_SRC org
set display=lastline " display partial lines at the bottom of the screen
#+END_SRC
Set encoding as utf-8, because this might be the default on Linux, but that isn't the case on Windows (there the encoding is some ~cp1253~ nonsense - looking at Wikipedia it seems this is another name for an encoding called [[https://en.wikipedia.org/wiki/Windows-1253][Windows-1253]], an obsolete encoding for Greek).
#+BEGIN_SRC org
set encoding=utf-8
#+END_SRC
Set backspace, because it might already be defined like that on Linux, but not on Windows.
#+BEGIN_SRC org
set backspace=indent,eol,start
#+END_SRC
Enable mouse in the terminal as well. The mouse is already enabled on the gui by default, but not on the terminal. This fixes that.
#+BEGIN_SRC org
set mouse=a
#+END_SRC
** Keybindings
Keymap to have enter add a new line below the current one without entering insert mode - good for spacing out text
#+BEGIN_SRC org
nnoremap <CR> o<Esc>k
#+END_SRC
Delete letters without putting them in the clipboard
#+BEGIN_SRC org
nnoremap x "_x
#+END_SRC
Visual mode remapping so that the stuff I replace by pasting isn't copied to the clipboard (from [[https://stackoverflow.com/a/10723838]])
#+BEGIN_SRC org
" don't copy to the clipboard the stuff I replace by pasting
vnoremap p "_dp
vnoremap P "_dP
#+END_SRC
I sometimes want to be able to move by visual lines, and rebinding j and k to gj and gk broke prefixing j and k with numbers, so I bound these commands to the arrows which aren't used with a prefix (if at all) anyways.
#+BEGIN_SRC org
nnoremap <Up> gk
nnoremap <Down> gj
#+END_SRC
Keymap to save with ctrl-s. I decided to add this because sometimes I want to use a one-handed shortcut, since I might be holding something else (e.g. a book) with my other hand. However, I read online that this same shortcut is used as a stop signal by terminals, thus this keymap will only be active in Gvim (where I do my editing 99% of the time anyways). ~:up[date]~ is a command that writes the buffer only if it has been modified, which thus leaves the modification time unchanged if that is not the case.
#+BEGIN_SRC org
if has('gui_running')
nnoremap <silent> <c-s> :update<CR>
endif
#+END_SRC
** Netrw
Add relative line numbers to netrw: The below setting will help me navigate netrw buffers more easily, by showing relative line numbers.
#+BEGIN_SRC org
let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro nobl'
#+END_SRC
A note in regards to netrw: My mileage with it varies. On my Linux machine it exhibits no bugs whatsoever, so I'm fine with using it whenever I need to navigate the filesystem there. On my Windows machine however it exhibits enough bugs to annoy me and make me look for an alternative file browser. In this case (that is whenever netrw acts all buggy), [[https://github.com/cocopon/vaffle.vim][Vaffle]] is the solution that works the best for me. In short, I occasionally use the Vaffle plugin but only on those cases where netrw exhibits enough bugs to make me not want to use it.
* Search settings
Display search matches as characters are entered
#+BEGIN_SRC org
set incsearch " display search matches as characters are entered
#+END_SRC
Highlight matches
#+BEGIN_SRC org
set hlsearch " highlight matches
#+END_SRC
ignorecase - Case insensitive search e.g. if I want to find Foo as well when searching for /foo
#+BEGIN_SRC org
set ignorecase          " case-insensitive search
#+END_SRC
smartcase - override the previous setting when the search pattern uses capitals e.g. /Foo finds only Foo.
#+BEGIN_SRC org
set smartcase " override the previous when search pattern uses capitals e.g. /Foo finds only Foo
#+END_SRC
* Custom statusline
I found that vim has a statusline, and wanted to have it be similar to emacs's modeline. I was tempted to use [[https://github.com/itchyny/lightline.vim][lightline]], but then noticed that, because it needs separate theming, would look out of place with my home-made theme. So I made a custom statusline instead. Here is a good place to get started with the subject: [[https://shapeshed.com/vim-statuslines/]]
#+BEGIN_SRC org
set laststatus=2 " always show status line
" beginning of statusline
set statusline=
set statusline+=\ %{&fileencoding?&fileencoding:&encoding} " encoding
set statusline+=\(%{&fileformat}\) " file format
set statusline+=\ %t " name of file in the buffer
set statusline+=%m " modified flag
set statusline+=%h " help buffer flag
set statusline+=%r " read-only flag
set statusline+=%=
set statusline+=\ %k " keymap
set statusline+=\ %y " filetype
set statusline+=\ L%l " current line
set statusline+=\ %p%% " percentage into file
set statusline+=\ 
" end of statusline
#+END_SRC
* Nationality and keymap settings
Enable greek input - switch inputs with ctrl+6
#+BEGIN_SRC org
set keymap=greek_utf-8  " enables greek input - switch inputs with ctrl+6
#+END_SRC
iminsert - I don't want greek as default though in insert mode, so this setting makes sure that's the case.
#+BEGIN_SRC org
set iminsert=0 " I dont want greek as default though in insert mode
#+END_SRC
imsearch - with this, when searching it inherits the keymap currently used in insert mode.
#+BEGIN_SRC org
set imsearch=-1 " with this when searching it inherits the keymap currently used in insert mode
#+END_SRC
** Greek letters mapping.
Map Greek letters to the respective on the keyboard Latin ones - for Normal, Visual, Select and Operator pending modes - in case I've forgotten to switch my system keyboard language from Greek (idea from [[https://www.void.gr/kargig/dot/vimrc]]). Another unforeseen advantage of these mappings for me is that I can now use the commands that jump to letters (f,F,t,T) in order to jump to Greek letters without having to change my system keyboard layout midway through.
#+BEGIN_SRC org
map α a
map Α A
map β b
map Β B
map γ g
map Γ G
map δ d
map Δ D
map ε e
map Ε E
map ζ z
map Ζ Z
map η h
map Η H
map θ u
map Θ U
map ι i
map Ι I
map κ k
map λ l
map Λ L
map μ m
map Μ M
map ν n
map Ν N
map ξ j
map Ξ J
map ο o
map Ο O
map π p
map Π P
map ρ r
map Ρ R
map σ s
map ς w
map τ t
map Τ T
map υ y
map φ f
map Φ F
map χ x
map ψ c
map ω v
map Ω V
map γγ gg
map αε ae
#+END_SRC
Tip for Greek spell-checking: write in the file you want to spellcheck ~:setlocal spell spelllang=el~, and it will download all necessary files and do the spellchecking by itself (tip from [[https://forum.ubuntu-gr.org/viewtopic.php?f=23&t=18008][Ubuntu-gr Forum - vim και ελληνικός ορθογράφος]])
